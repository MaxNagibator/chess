@{
    ViewData["Title"] = "Field";
}


<div id="field">

</div>
<script>

    window.onload = function () {

        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", '/Home/GetField', false);
        xmlHttp.send(null);
        var response = xmlHttp.responseText;
        var data = JSON.parse(response);
        console.log(data.notation);
        console.log(data.availableMoves);
        alert('privet ' + data.player);
        initField(data.notation, data.availableMoves);
    };

    const PieceTypes = {
        Bishop: 'Bishop',
        King: 'King',
        Knight: 'Knight',
        Pawn: 'Pawn',
        Queen: 'Queen',
        Rook: 'Rook'
    }

    const Side = {
        White: 'White',
        Black: 'Black'
    }

    function initField(notation, availableMoves) {

        console.log(notation);

        //rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1

        let notationParts = notation.split(' ');
        let pieceLocation = notationParts[0];
        let pieceLocationLines = pieceLocation.split('/');
        let cellColorIndex = 0;
        var target = document.querySelector("#field");

        var draggables = [];
        var dropZones = [];

        for (let i = 0; i < 8; i++) {
            let line = pieceLocationLines[i];
            var divLine = document.createElement('div');
            divLine.classList.add('line');
            target.appendChild(divLine);
            var posX = 0;
            for (let posIndex = 0; posIndex < line.length; posIndex++) {
                var posY = 7 - i;
                let pos = line[posIndex];
                var emptyFields = pos * 1;
                if (Number.isInteger(emptyFields)) {
                    for (let cellsCount = emptyFields; cellsCount > 0; cellsCount--) {
                        // todo обобщить с дублированием снизу
                        var div = document.createElement('div');
                        div.classList.add('column');
                        if (cellColorIndex % 2 === 0) {
                            div.classList.add('position-white');
                        } else {
                            div.classList.add('position-black');
                        }
                        div.setAttribute('data-position-x', posX);
                        div.setAttribute('data-position-y', posY);

                        divLine.appendChild(div);
                        dropZones.push(div);
                        cellColorIndex++;
                        posX++;
                    }

                } else {
                    var div = document.createElement('div');
                    divLine.appendChild(div);
                    div.classList.add('column');
                    if (cellColorIndex % 2 === 0) {
                        div.classList.add('position-white');
                    } else {
                        div.classList.add('position-black');
                    }
                    div.setAttribute('data-position-x', posX);
                    div.setAttribute('data-position-y', posY);

                    divLine.appendChild(div);
                    cellColorIndex++;
                    let piece = getPieceByNotation(pos);
                    var img = document.createElement('img');
                    var imgSrcName = piece.Type + "-" + piece.Side + '.png';
                    img.src = '/Content/Images/Piece/' + imgSrcName;
                    div.appendChild(img);
                    dropZones.push(div);
                    draggables.push(img);
                    posX++;
                }
            }

            cellColorIndex++;
            var target = document.querySelector("#field");
        }

        let dnd_successful;
        for (let i = 0; i < draggables.length; i++) {
            draggables[i].addEventListener('dragstart', function (event) {
                event.target.classList.add('piece-select');

                let posX = event.target.parentElement.getAttribute('data-position-x');
                let posY = event.target.parentElement.getAttribute('data-position-y');
                var moves = getMoves(availableMoves, posX, posY);
                var cells = document.getElementsByClassName('column');
                for (let moveIndex = 0; moveIndex < moves.length; moveIndex++) {
                    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                        if (cells[cellIndex].getAttribute('data-position-x') == moves[moveIndex].x
                            && cells[cellIndex].getAttribute('data-position-y') == moves[moveIndex].y) {
                            cells[cellIndex].classList.add('piece-move-target-good');
                        }
                    }
                }
                event.dataTransfer.effectAllowed = "move";
                dnd_successful = false;
            });

            draggables[i].addEventListener('dragend', function (event) {
                if (dnd_successful) {
                    let fromX = event.target.parentElement.getAttribute('data-position-x');
                    let fromY = event.target.parentElement.getAttribute('data-position-y');

                    let toX = placeForDropPiece.getAttribute('data-position-x');
                    let toY = placeForDropPiece.getAttribute('data-position-y');
                    SendRequest({
                        url: '/Home/Move',
                        method: 'POST',
                        body: {
                            fromX: fromX,
                            fromY: fromY,
                            toX: toX,
                            toY: toY,
                        },
                        success: function (data) {
                            var data2 = JSON.parse(data.responseText);
                            var field = document.getElementById('field');
                            field.innerHTML = '';
                            initField(data2.notation, data2.availableMoves);
                        },
                        error: function () {
                            alert('shadow bolt');
                        }
                    });
                }
                else {
                }
                event.target.classList.remove('piece-select');

                var cells = document.getElementsByClassName('column');
                for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                    cells[cellIndex].classList.remove('piece-move-target-good');
                    cells[cellIndex].classList.remove('piece-move-target-bad');
                }
            });
        }

        function getMoves(availableMoves, x, y) {
            for (let i = 0; i < availableMoves.length; i++) {
                if (availableMoves[i].from.x == x
                    && availableMoves[i].from.y == y) {
                    return availableMoves[i].to;
                }
            }
            console.error('not found moves for piece in ' + x + '/' + y);
        }

        let placeForDropPiece;
        for (let i = 0; i < dropZones.length; i++) {
            dropZones[i].addEventListener('dragenter', function (event) {
                if (event.target.classList.contains('column') &&
                    !event.target.classList.contains('piece-move-target-good')) {
                    event.target.classList.add('piece-move-target-bad');
                }
                event.preventDefault();
            });

            dropZones[i].addEventListener('dragleave', function (event) {
                if (event.target.classList.contains('column') &&
                    !event.target.classList.contains('piece-move-target-good')) {
                    event.target.classList.remove('piece-move-target-bad');
                }
            });

            dropZones[i].addEventListener('dragover', function (event) {
                event.dataTransfer.dropEffect = "move";
                event.preventDefault();
                return false;
            });

            dropZones[i].addEventListener('drop', function (event) {

                //todo переименовать column в cell/position/...
                if ((event.target.classList.contains('column')
                    && event.target.classList.contains('piece-move-target-good'))

                    || (event.target.parentElement.classList.contains('column')
                        && event.target.parentElement.classList.contains('piece-move-target-good'))
                ) {
                    //event.target.classList.remove('piece-move-target-good');
                    placeForDropPiece = event.target;
                    if (!placeForDropPiece.classList.contains('column')) {
                        placeForDropPiece = placeForDropPiece.parentElement;
                    }
                    dnd_successful = true;
                    event.preventDefault();
                }
            });
        }



        function getPieceByNotation(pos) {
            var toUpper = pos.toUpperCase();

            var piece = {
                Side: pos === toUpper ? Side.White : Side.Black,
                Type: GetTypeByChar(toUpper),
            };

            return piece;
        }

        function GetTypeByChar(char) {
            switch (char) {
                case 'R':
                    return PieceTypes.Rook;
                case 'N':
                    return PieceTypes.Knight;
                case 'B':
                    return PieceTypes.Bishop;
                case 'Q':
                    return PieceTypes.Queen;
                case 'K':
                    return PieceTypes.King;
                case 'P':
                    return PieceTypes.Pawn;
                default:
                    console.error('type not recognized: ' + char);
                    return null;
            }
        }
    }
</script>